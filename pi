#!/bin/bash
#
# Pi Coding Agent - Container Entrypoint
#
# Run pi-coding-agent inside an Apple container.
# Designed to be used as a Terminal.app/Ghostty command.
#

set -e

# Configuration
IMAGE_NAME="pi-agent:latest"
CONTAINER_NAME="pi-agent"
BASE_PATH="${PI_CONTAINER_PATH:-$HOME/pi}"

# Resolve symlink to get actual script directory
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [ -L "$SCRIPT_PATH" ]; do
    SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ $SCRIPT_PATH != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_PATH")" && pwd)"

WORKSPACE="${BASE_PATH}/workspace"
CONFIG_ROOT="${BASE_PATH}/config"
LOCAL_CONFIG_DIR="$HOME/.pi/agent"
AUTH_FILE="$LOCAL_CONFIG_DIR/auth.json"
PROJECT_SKILLS_DIR="$SCRIPT_DIR/skills"
HEADLESS_BROWSER=${PI_BROWSER:-0}
BROWSER_ALLOWED=0
RESTRICT_WORKSPACE=0
WORKSPACE_MOUNT="$WORKSPACE"

CONFIG_MODE="local"
CONFIG_DIR_OVERRIDE=""
PROFILE_NAME=""
IMPORT_MODE=""
CONFIG_DIR="$CONFIG_ROOT"

PREFS_FILE="$BASE_PATH/.pi-container-prefs"
CONTAINER_CONFIG_PATH="/home/node/.pi/agent"
CONTAINER_HOME="/home/node"
CONTAINER_USER="node"
SSH_ENABLED=""

BROWSER_TOOLS_DIR="$CONTAINER_CONFIG_PATH/skills/pi-skills/browser-tools"
BROWSER_BOOTSTRAP_CMD="cd $BROWSER_TOOLS_DIR && if [ ! -d node_modules ]; then npm install --silent; fi; ./browser-start.js --headless --port 9222 || true"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
DIM='\033[2m'
BOLD='\033[1m'
NC='\033[0m'

# Spinner for long operations
spinner() {
    local pid=$1
    local msg=$2
    local spin='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
    local i=0
    tput civis  # hide cursor
    while kill -0 $pid 2>/dev/null; do
        printf "\r${CYAN}${spin:$i:1}${NC} %s" "$msg"
        i=$(((i + 1) % ${#spin}))
        sleep 0.1
    done
    tput cnorm  # show cursor
    printf "\r${GREEN}✓${NC} %s\n" "$msg"
}

# Preferences
pref_get() {
    [ -f "$PREFS_FILE" ] || return 1
    grep -E "^$1=" "$PREFS_FILE" | tail -1 | cut -d= -f2-
}

pref_set() {
    local key="$1"
    local value="$2"
    mkdir -p "$(dirname "$PREFS_FILE")" 2>/dev/null || true
    grep -v -E "^${key}=" "$PREFS_FILE" 2>/dev/null > "${PREFS_FILE}.tmp" || true
    echo "${key}=${value}" >> "${PREFS_FILE}.tmp"
    mv "${PREFS_FILE}.tmp" "$PREFS_FILE"
}

pref_prompt() {
    local key="$1"
    local prompt="$2"
    local default="$3"

    local existing
    existing=$(pref_get "$key" || true)
    if [ -n "$existing" ]; then
        echo "$existing"
        return 0
    fi

    if [ -t 0 ] && [ -t 1 ]; then
        read -p "$prompt" -n 1 -r
        echo ""
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            pref_set "$key" "yes"
            echo "yes"
        else
            pref_set "$key" "no"
            echo "no"
        fi
    else
        pref_set "$key" "$default"
        echo "$default"
    fi
}

set_container_paths() {
    if [ "$CONTAINER_USER" = "root" ]; then
        CONTAINER_HOME="/root"
        CONTAINER_CONFIG_PATH="/root/.pi/agent"
    else
        CONTAINER_HOME="/home/node"
        CONTAINER_CONFIG_PATH="/home/node/.pi/agent"
    fi
    BROWSER_TOOLS_DIR="$CONTAINER_CONFIG_PATH/skills/pi-skills/browser-tools"
    BROWSER_BOOTSTRAP_CMD="cd $BROWSER_TOOLS_DIR && if [ ! -d node_modules ]; then npm install --silent; fi; ./browser-start.js --headless --port 9222 || true"
}

# Print header
header() {
    echo ""
    echo -e "${BOLD}${BLUE}┌────────────────────────────────┐${NC}"
    echo -e "${BOLD}${BLUE}│${NC}        ${BOLD}Pi Coding Agent${NC}         ${BOLD}${BLUE}│${NC}"
    echo -e "${BOLD}${BLUE}│${NC}    ${DIM}Isolated Linux Container${NC}    ${BOLD}${BLUE}│${NC}"
    echo -e "${BOLD}${BLUE}└────────────────────────────────┘${NC}"
    echo ""
}

# Print status info
status_info() {
    echo -e "${DIM}Workspace:${NC} $WORKSPACE_MOUNT"
    echo -e "${DIM}Config:${NC}    $CONFIG_DIR"
    echo ""
}

# Show help
show_help() {
    header
    echo -e "${BOLD}Usage:${NC}"
    echo "  pi-container                      Launch pi in /workspace"
    echo "  pi-container --project ${CYAN}<name>${NC}    Launch pi in project folder"
    echo "  pi-container project ${CYAN}<name>${NC}     Same as --project"
    echo "  pi-container --project ${CYAN}<name>${NC} --browser  Launch pi + headless browser"
    echo "  pi-container --project ${CYAN}<name>${NC} --restrict  Mount only that project"
    echo "  pi-container --ssh                Enable SSH agent forwarding"
    echo "  pi-container --no-ssh             Disable SSH forwarding"
    echo "  pi-container shell --root         Root shell (for apt install)"
    echo "  pi-container projects             List all projects"
    echo "  pi-container shell                Open bash shell"
    echo "  pi-container status               Show container status"
    echo "  pi-container stop                 Stop the container"
    echo "  pi-container restart              Recreate container and launch pi"
    echo "  pi-container reset                Delete container (keeps data)"
    echo "  pi-container rebuild              Rebuild image"
    echo "  pi-container help                 Show this help"
    echo ""
    echo -e "${BOLD}Config modes:${NC}"
    echo "  --config local        Use ~/pi/config (default)"
    echo "  --config shared       Share ~/.pi/agent (local pi)"
    echo "  --config project      Use ~/pi/config/projects/<project>"
    echo "  --config fresh        New profile under ~/pi/config/profiles"
    echo "  --profile <name>      Use ~/pi/config/profiles/<name>"
    echo "  --import-config       Merge ~/.pi/agent into config dir"
    echo "  --import-config=force Overwrite config dir from ~/.pi/agent"
    echo ""
    echo -e "${BOLD}Pi passthrough:${NC}"
    echo "  pi-container config               → pi config"
    echo "  pi-container install npm:pkg      → pi install npm:pkg"
    echo "  pi-container pi --help            → pi --help"
    echo "  pi-container -- --help            → pi --help"
    echo ""
    echo -e "${BOLD}Projects:${NC}"
    echo "  pi-container --project myapp             Create/open ~/pi/workspace/myapp"
    echo "  pi-container --project myapp --restrict  Mount only that project"
    echo "  pi-container project myapp               Same as above"
    echo "  pi-container --project myapp --browser   Start headless browser too"
    echo "  pi-container project list                List all projects"
    echo ""
    echo -e "${BOLD}Directories:${NC}"
    echo "  $WORKSPACE_MOUNT   →  /workspace          (mounted)"
    echo "  $CONFIG_DIR        →  $CONTAINER_CONFIG_PATH   (pi config)"
    echo ""
    echo -e "${BOLD}Environment:${NC}"
    echo "  PI_CONTAINER_PATH   Override base path (default: ~/pi)"
    echo "  PI_SSH              1/0 to enable/disable SSH forwarding"
    echo "  PI_BROWSER          1/0 to allow headless browser"
    echo "  PI_NO_AUTO_INSTALL  1 to disable auto-install of container tool"
    echo "  PI_NODE_IMAGE       Override base image (build arg)"
    echo "  PI_AGENT_VERSION    Override pi version (build arg)"
    echo ""
    exit 0
}

# List projects
list_projects() {
    header
    echo -e "${BOLD}Projects in ~/pi/workspace:${NC}"
    echo ""
    
    if [ ! -d "$WORKSPACE" ]; then
        echo -e "  ${DIM}(no projects yet)${NC}"
        echo ""
        echo -e "Create one with: ${CYAN}pi-container --project myproject${NC}"
        echo ""
        exit 0
    fi
    
    # Find directories, excluding hidden ones
    local count=0
    while IFS= read -r dir; do
        if [ -n "$dir" ]; then
            local name="${dir#$WORKSPACE/}"
            local files=$(find "$dir" -maxdepth 1 -type f 2>/dev/null | wc -l | tr -d ' ')
            local subdirs=$(find "$dir" -maxdepth 1 -type d 2>/dev/null | wc -l | tr -d ' ')
            subdirs=$((subdirs - 1))  # exclude the dir itself
            echo -e "  ${GREEN}●${NC} ${BOLD}$name${NC}"
            echo -e "    ${DIM}$files files, $subdirs folders${NC}"
            count=$((count + 1))
        fi
    done < <(find "$WORKSPACE" -mindepth 1 -maxdepth 1 -type d ! -name ".*" | sort)
    
    if [ $count -eq 0 ]; then
        echo -e "  ${DIM}(no projects yet)${NC}"
        echo ""
        echo -e "Create one with: ${CYAN}pi-container --project myproject${NC}"
    fi
    echo ""
    exit 0
}

# Container helpers
container_exists() {
    container inspect "$CONTAINER_NAME" 2>/dev/null | grep -q '"status"'
}

container_running() {
    container inspect "$CONTAINER_NAME" 2>/dev/null | grep -q '"status" *: *"running"'
}

container_uses_sleep() {
    container inspect "$CONTAINER_NAME" 2>/dev/null | grep -q "sleep infinity"
}

container_has_ssh() {
    container inspect "$CONTAINER_NAME" 2>/dev/null | grep -q "ssh-auth.sock"
}

container_workspace_source() {
    container inspect "$CONTAINER_NAME" 2>/dev/null | python3 - <<'PY'
import json,sys
try:
    data=json.load(sys.stdin)
    if not data:
        sys.exit(0)
    mounts=data[0].get("configuration",{}).get("mounts",[])
    for m in mounts:
        if m.get("destination") == "/workspace":
            print(m.get("source",""))
            sys.exit(0)
except Exception:
    pass
PY
}

ensure_container_compat() {
    if container_exists && ! container_uses_sleep; then
        echo -e "${YELLOW}Updating container entrypoint...${NC}"
        container stop "$CONTAINER_NAME" 2>/dev/null || true
        container delete "$CONTAINER_NAME" 2>/dev/null || true
    fi

    if container_exists && [ "$SSH_ENABLED" = "yes" ] && ! container_has_ssh; then
        echo -e "${YELLOW}Recreating container to enable SSH forwarding...${NC}"
        container stop "$CONTAINER_NAME" 2>/dev/null || true
        container delete "$CONTAINER_NAME" 2>/dev/null || true
    fi

    if container_exists && [ "$SSH_ENABLED" = "no" ] && container_has_ssh; then
        if [ -t 0 ] && [ -t 1 ]; then
            echo ""
            echo -e "${YELLOW}SSH forwarding is enabled in the existing container.${NC}"
            read -p "Recreate container to disable SSH? (y/N) " -n 1 -r
            echo ""
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                container stop "$CONTAINER_NAME" 2>/dev/null || true
                container delete "$CONTAINER_NAME" 2>/dev/null || true
            fi
        fi
    fi

    if container_exists && [ "$RESTRICT_WORKSPACE" = "1" ]; then
        local source
        source=$(container_workspace_source || true)
        if [ -n "$source" ] && [ "$source" != "$WORKSPACE_MOUNT" ]; then
            if [ -t 0 ] && [ -t 1 ]; then
                echo ""
                echo -e "${YELLOW}Workspace is mounted as:${NC} $source"
                echo -e "${YELLOW}Restricted mount requested:${NC} $WORKSPACE_MOUNT"
                read -p "Recreate container to apply restriction? (y/N) " -n 1 -r
                echo ""
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    container stop "$CONTAINER_NAME" 2>/dev/null || true
                    container delete "$CONTAINER_NAME" 2>/dev/null || true
                fi
            fi
        fi
    fi
}

wait_for_container_running() {
    container_running && return
    (while ! container_running; do sleep 0.2; done) &
    spinner $! "Starting container"
}

# Show status
show_status() {
    header
    echo -e "${BOLD}Container:${NC}"
    if container_exists; then
        if container_running; then
            echo -e "  State: ${GREEN}● running${NC}"
        else
            echo -e "  State: ${YELLOW}○ stopped${NC}"
        fi
    else
        echo -e "  State: ${DIM}not created${NC}"
    fi
    echo ""
    echo -e "${BOLD}Image:${NC}"
    if image_exists; then
        echo -e "  ${GREEN}✓${NC} $IMAGE_NAME"
    else
        echo -e "  ${DIM}not built${NC}"
    fi
    echo ""
    echo -e "${BOLD}Directories:${NC}"
    echo "  ~/pi/workspace   $([ -d "$WORKSPACE" ] && echo -e "${GREEN}✓${NC}" || echo -e "${DIM}(will be created)${NC}")"
    echo "  $CONFIG_DIR   $([ -d "$CONFIG_DIR" ] && echo -e "${GREEN}✓${NC}" || echo -e "${DIM}(will be created)${NC}")"
    echo ""
    exit 0
}

# Stop container
stop_container() {
    if container list 2>/dev/null | grep -q "$CONTAINER_NAME"; then
        echo -e "${YELLOW}Stopping container...${NC}"
        container stop "$CONTAINER_NAME"
        echo -e "${GREEN}✓${NC} Container stopped"
    else
        echo -e "${DIM}Container is not running${NC}"
    fi
    exit 0
}

# Reset container
reset_container() {
    echo -e "${YELLOW}This will delete the container.${NC}"
    echo -e "${DIM}Your files in ~/pi will NOT be deleted.${NC}"
    echo ""
    read -p "Continue? (y/N) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        container stop "$CONTAINER_NAME" 2>/dev/null || true
        container delete "$CONTAINER_NAME" 2>/dev/null || true
        echo -e "${GREEN}✓${NC} Container deleted"
    fi
    exit 0
}

# Restart container (recreate with fresh mounts)
restart_container() {
    echo -e "${CYAN}Restarting container...${NC}"
    container stop "$CONTAINER_NAME" 2>/dev/null || true
    container delete "$CONTAINER_NAME" 2>/dev/null || true
    echo -e "${GREEN}✓${NC} Container removed, will recreate on next run"
    echo ""
    # Continue to run pi (don't exit)
}

# Build image helper (supports pinning)
build_image() {
    local args=()
    if [ -n "${PI_NODE_IMAGE:-}" ]; then
        args+=("--build-arg" "NODE_IMAGE=${PI_NODE_IMAGE}")
    fi
    if [ -n "${PI_AGENT_VERSION:-}" ]; then
        args+=("--build-arg" "PI_VERSION=${PI_AGENT_VERSION}")
    fi
    container build "${args[@]}" -t "$IMAGE_NAME" "$SCRIPT_DIR"
}

# Rebuild image
rebuild_image() {
    echo -e "${YELLOW}This will rebuild the image and delete the container.${NC}"
    echo ""
    read -p "Continue? (y/N) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        # Ensure container system is running
        if ! container list &>/dev/null; then
            echo -e "${CYAN}Starting container system...${NC}"
            container system start >/dev/null 2>&1 &
            spinner $! "Starting container system"
        fi

        container stop "$CONTAINER_NAME" 2>/dev/null || true
        container delete "$CONTAINER_NAME" 2>/dev/null || true
        container image delete "$IMAGE_NAME" 2>/dev/null || true
        echo ""
        echo -e "${CYAN}Building image...${NC}"
        build_image
        echo ""
        echo -e "${GREEN}✓${NC} Image rebuilt"
    fi
    exit 0
}

# Check macOS version
check_macos_version() {
    local version=$(sw_vers -productVersion | cut -d. -f1)
    if [ "$version" -lt 26 ] 2>/dev/null; then
        echo -e "${YELLOW}⚠${NC}  Warning: Apple container requires macOS 26 (Tahoe)"
        echo -e "${DIM}   You're on macOS $(sw_vers -productVersion)${NC}"
        echo ""
    fi
}

# Install Apple container tool if missing
install_container_tool() {
    echo ""
    echo -e "${YELLOW}Apple's container tool is not installed.${NC}"
    echo ""

    if [ "${PI_NO_AUTO_INSTALL:-0}" = "1" ]; then
        echo -e "${DIM}Auto-install disabled (PI_NO_AUTO_INSTALL=1).${NC}"
        echo -e "${DIM}Install manually: https://github.com/apple/container/releases${NC}"
        exit 1
    fi

    local allow
    allow=$(pref_prompt "auto_install_container" "Install Apple container tool now? (y/N) " "no")
    if [ "$allow" != "yes" ]; then
        echo -e "${DIM}Install manually: https://github.com/apple/container/releases${NC}"
        exit 1
    fi
    
    echo ""
    echo -e "${CYAN}Fetching latest release...${NC}"
    PKG_URL=$(curl -s https://api.github.com/repos/apple/container/releases/latest | grep "browser_download_url.*pkg" | head -1 | cut -d '"' -f 4)
    
    if [ -z "$PKG_URL" ]; then
        echo -e "${RED}✗${NC} Could not find installer"
        echo -e "${DIM}Install manually: https://github.com/apple/container/releases${NC}"
        exit 1
    fi
    
    TMPFILE=$(mktemp /tmp/container-installer.XXXXXX.pkg)
    
    echo -e "${CYAN}Downloading...${NC}"
    curl -L --progress-bar -o "$TMPFILE" "$PKG_URL"
    
    echo ""
    echo -e "${CYAN}Installing...${NC} ${DIM}(requires admin password)${NC}"
    sudo installer -pkg "$TMPFILE" -target /
    
    rm -f "$TMPFILE"
    
    echo ""
    echo -e "${CYAN}Starting container system...${NC}"
    /usr/local/bin/container system start
    
    echo ""
    echo -e "${GREEN}✓${NC} Installation complete!"
    echo ""
}

# First run welcome (only for true first-timers)
first_run_welcome() {
    # Skip welcome if container tool is already installed (user knows what they're doing)
    command -v container &>/dev/null && return
    
    header
    echo -e "${GREEN}Welcome to Pi Container!${NC}"
    echo ""
    echo "This will set up an isolated Linux environment with pi-coding-agent."
    echo ""
    echo -e "${BOLD}What's being created:${NC}"
    echo "  • ~/pi/workspace   Your project files"
    echo "  • ~/pi/config      Pi settings & skills"
    echo "  • Container image  Linux + Node.js + pi"
    echo ""
    read -p "Press Enter to continue..."
    echo ""
}

# Sync project-local skills into config
sync_project_skills() {
    # Skip if we're sharing local config to avoid mutating host pi
    if [ "$CONFIG_DIR" = "$LOCAL_CONFIG_DIR" ]; then
        return
    fi
    if [ -d "$PROJECT_SKILLS_DIR" ]; then
        mkdir -p "$CONFIG_DIR/skills"
        rsync -a "$PROJECT_SKILLS_DIR/" "$CONFIG_DIR/skills/"
    fi
}

ensure_browser_tools() {
    local target="$CONFIG_DIR/skills/pi-skills/browser-tools"
    local source="$PROJECT_SKILLS_DIR/pi-skills/browser-tools"

    if [ "$HEADLESS_BROWSER" != "1" ]; then
        return
    fi

    if [ -d "$target" ]; then
        return
    fi

    if [ ! -d "$source" ]; then
        echo -e "${RED}Browser tools not found in project skills.${NC}"
        return
    fi

    if [ "$CONFIG_DIR" = "$LOCAL_CONFIG_DIR" ]; then
        if [ -t 0 ] && [ -t 1 ]; then
            echo ""
            echo -e "${YELLOW}Headless browser requires browser-tools skill.${NC}"
            echo -e "Copy into local pi config ($LOCAL_CONFIG_DIR)?"
            read -p "Copy now? (y/N) " -n 1 -r
            echo ""
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                mkdir -p "$LOCAL_CONFIG_DIR/skills"
                rsync -a "$source/" "$LOCAL_CONFIG_DIR/skills/pi-skills/browser-tools/"
            fi
        fi
        return
    fi

    mkdir -p "$CONFIG_DIR/skills/pi-skills"
    rsync -a "$source/" "$target/"
}

# Import local pi config into target config dir
import_local_config() {
    local mode="${1:-merge}"
    if [ ! -d "$LOCAL_CONFIG_DIR" ]; then
        return
    fi
    if [ "$CONFIG_DIR" = "$LOCAL_CONFIG_DIR" ]; then
        return
    fi
    mkdir -p "$CONFIG_DIR"

    local rsync_flags=("-a")
    if [ "$mode" = "force" ]; then
        rsync_flags+=("--delete")
    fi

    rsync "${rsync_flags[@]}" \
        --exclude 'skills/' \
        --exclude 'cache/' \
        --exclude 'logs/' \
        "$LOCAL_CONFIG_DIR/" "$CONFIG_DIR/"
}

# Start headless Chromium inside container (if enabled)
start_headless_browser_in_container() {
    [ "$HEADLESS_BROWSER" = "0" ] && return
    [ "$CONTAINER_CMD" != "pi" ] && return

    # fire-and-forget; browser-start exits if already running
    container exec -d ${USER_FLAG[@]} ${BROWSER_ENV[@]} "$CONTAINER_NAME" /bin/bash -lc "$BROWSER_BOOTSTRAP_CMD" >/dev/null 2>&1 || true
}

# Handle commands
case "${1:-}" in
    help|--help|-h)
        show_help
        ;;
    status)
        show_status
        ;;
    stop)
        stop_container
        ;;
    reset)
        reset_container
        ;;
    restart)
        restart_container
        shift
        ;;
    rebuild)
        rebuild_image
        ;;
    projects|list)
        list_projects
        ;;
    project)
        if [ "${2:-}" = "list" ] || [ -z "${2:-}" ]; then
            list_projects
        fi
        ;;
esac

# Determine command to run in container
CONTAINER_CMD="pi"
WORKDIR="/workspace"
PROJECT_NAME=""

ARGS=()
while [ $# -gt 0 ]; do
    case "$1" in
        shell|sh|bash)
            CONTAINER_CMD="/bin/bash"
            shift
            ARGS+=("$@")
            break
            ;;
        --browser)
            HEADLESS_BROWSER=1
            BROWSER_ALLOWED=1
            shift
            ;;
        --no-browser)
            HEADLESS_BROWSER=0
            BROWSER_ALLOWED=0
            shift
            ;;
        --restrict|--project-only)
            RESTRICT_WORKSPACE=1
            shift
            ;;
        --ssh)
            SSH_ENABLED="yes"
            shift
            ;;
        --no-ssh)
            SSH_ENABLED="no"
            shift
            ;;
        --root)
            CONTAINER_USER="root"
            shift
            ;;
        --project|-p)
            PROJECT_NAME="$2"
            shift 2
            ;;
        project)
            shift
            PROJECT_NAME="$1"
            shift
            ;;
        --config)
            CONFIG_MODE="$2"
            shift 2
            ;;
        --config=*)
            CONFIG_MODE="${1#--config=}"
            shift
            ;;
        --config-dir)
            CONFIG_DIR_OVERRIDE="$2"
            shift 2
            ;;
        --profile)
            PROFILE_NAME="$2"
            shift 2
            ;;
        --import-config)
            IMPORT_MODE="merge"
            shift
            ;;
        --import-config=force|--import-config=overwrite)
            IMPORT_MODE="force"
            shift
            ;;
        --import-config=merge)
            IMPORT_MODE="merge"
            shift
            ;;
        --force|--overwrite)
            if [ -n "$IMPORT_MODE" ]; then
                IMPORT_MODE="force"
                shift
            else
                ARGS+=("$1")
                shift
            fi
            ;;
        --fresh)
            CONFIG_MODE="fresh"
            shift
            ;;
        --)
            shift
            ARGS+=("$@")
            break
            ;;
        *)
            ARGS+=("$1")
            shift
            ;;
    esac

done

if [ -n "$PROJECT_NAME" ]; then
    if [ "$RESTRICT_WORKSPACE" = "1" ]; then
        WORKDIR="/workspace"
        WORKSPACE_MOUNT="$WORKSPACE/$PROJECT_NAME"
    else
        WORKDIR="/workspace/$PROJECT_NAME"
    fi
fi

set -- "${ARGS[@]}"

if [ "$CONTAINER_USER" = "root" ] && [ "$CONTAINER_CMD" = "pi" ]; then
    echo -e "${YELLOW}Warning:${NC} running pi as root. Config may use /root unless HOME is overridden."
fi

# If PI_BROWSER env is set, allow browser
if [ "${PI_BROWSER:-0}" = "1" ] || [ "${PI_BROWSER:-}" = "true" ]; then
    BROWSER_ALLOWED=1
fi

if [ "$RESTRICT_WORKSPACE" = "1" ] && [ -z "$PROJECT_NAME" ]; then
    echo -e "${RED}Error:${NC} --restrict requires --project <name>"
    exit 1
fi

# Resolve config directory
resolve_config_dir() {
    # Highest priority: explicit config dir
    if [ -n "$CONFIG_DIR_OVERRIDE" ]; then
        CONFIG_DIR="$CONFIG_DIR_OVERRIDE"
        return
    fi

    # Shared config (link to local pi)
    if [ "$CONFIG_MODE" = "shared" ]; then
        CONFIG_DIR="$LOCAL_CONFIG_DIR"
        return
    fi

    # Project config
    if [ "$CONFIG_MODE" = "project" ]; then
        if [ -z "$PROJECT_NAME" ]; then
            echo -e "${RED}Error:${NC} --config project requires --project <name>"
            exit 1
        fi
        CONFIG_DIR="$CONFIG_ROOT/projects/$PROJECT_NAME"
        return
    fi

    # Fresh profile
    if [ "$CONFIG_MODE" = "fresh" ]; then
        if [ -z "$PROFILE_NAME" ]; then
            PROFILE_NAME="fresh-$(date +%Y%m%d%H%M%S)"
        fi
        CONFIG_DIR="$CONFIG_ROOT/profiles/$PROFILE_NAME"
        return
    fi

    # Named profile
    if [ -n "$PROFILE_NAME" ]; then
        CONFIG_DIR="$CONFIG_ROOT/profiles/$PROFILE_NAME"
        return
    fi

    # Default
    CONFIG_DIR="$CONFIG_ROOT"
}

resolve_config_dir

# Determine SSH forwarding preference
if [ -z "$SSH_ENABLED" ]; then
    if [ -n "${PI_SSH:-}" ]; then
        if [ "${PI_SSH}" = "1" ] || [ "${PI_SSH}" = "true" ]; then
            SSH_ENABLED="yes"
        else
            SSH_ENABLED="no"
        fi
    else
        SSH_ENABLED=$(pref_prompt "ssh_forwarding" "Enable SSH agent forwarding into container? (y/N) " "no")
    fi
fi

# Check macOS version
check_macos_version

# Determine whether image supports non-root user
image_supports_user() {
    local user="$1"
    container run --rm "$IMAGE_NAME" /bin/bash -lc "id -u $user" >/dev/null 2>&1
}

# If using non-root user but image doesn't support it, prompt to rebuild or fallback
if [ "$CONTAINER_USER" != "root" ]; then
    if ! image_supports_user "$CONTAINER_USER"; then
        if [ -t 0 ] && [ -t 1 ]; then
            echo ""
            echo -e "${YELLOW}Image does not include user '${CONTAINER_USER}'.${NC}"
            read -p "Rebuild image now? (y/N) " -n 1 -r
            echo ""
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                rebuild_image
            else
                echo -e "${YELLOW}Falling back to root.${NC}"
                CONTAINER_USER="root"
            fi
        else
            CONTAINER_USER="root"
        fi
    fi
fi

set_container_paths

USER_FLAG=(--user "$CONTAINER_USER")
SSH_FLAG=()
if [ "$SSH_ENABLED" = "yes" ]; then
    SSH_FLAG=(--ssh)
fi

BROWSER_ENV=(--env PI_BROWSER_ALLOWED=0)
if [ "$BROWSER_ALLOWED" = "1" ]; then
    BROWSER_ENV=(--env PI_BROWSER_ALLOWED=1)
fi

# Check if container tool is available
if ! command -v container &> /dev/null; then
    install_container_tool
fi

# Check if container system is running
if ! container list &>/dev/null; then
    echo -e "${CYAN}Starting container system...${NC}"
    container system start >/dev/null 2>&1 &
    spinner $! "Starting container system"
fi

# Ensure directories exist
mkdir -p "$WORKSPACE"
if [ -n "$PROJECT_NAME" ]; then
    mkdir -p "$WORKSPACE/$PROJECT_NAME"
fi
if [ "$CONFIG_DIR" != "$LOCAL_CONFIG_DIR" ]; then
    mkdir -p "$CONFIG_DIR"
fi

# Import local config (one-time or on demand)
if [ "$CONFIG_DIR" != "$LOCAL_CONFIG_DIR" ]; then
    IMPORT_MARKER="$CONFIG_DIR/.imported-from-local"
    CONFIG_EMPTY=true
    if [ -d "$CONFIG_DIR" ] && [ "$(ls -A "$CONFIG_DIR" 2>/dev/null)" ]; then
        CONFIG_EMPTY=false
    fi

    if [ -n "$IMPORT_MODE" ]; then
        MODE="$IMPORT_MODE"
        if [ "$CONFIG_EMPTY" = false ] && [ "$MODE" = "merge" ]; then
            if [ -t 0 ] && [ -t 1 ]; then
                echo ""
                echo -e "${YELLOW}Target config not empty.${NC}"
                echo "Overwrite with local config from $LOCAL_CONFIG_DIR?"
                read -p "Overwrite? (y/N) " -n 1 -r
                echo ""
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    MODE="force"
                fi
            fi
        fi

        if [ "$MODE" = "force" ] && [ -t 0 ] && [ -t 1 ]; then
            echo ""
            echo -e "${YELLOW}This will overwrite:${NC} $CONFIG_DIR"
            read -p "Proceed? (y/N) " -n 1 -r
            echo ""
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                MODE="merge"
            fi
        fi

        import_local_config "$MODE"
        echo "yes" > "$IMPORT_MARKER" 2>/dev/null || true
    elif [ "$CONFIG_EMPTY" = true ] && [ ! -f "$IMPORT_MARKER" ]; then
        if [ -t 0 ] && [ -t 1 ] && [ -d "$LOCAL_CONFIG_DIR" ]; then
            echo ""
            echo -e "${YELLOW}Import local pi config from:${NC} $LOCAL_CONFIG_DIR"
            echo -e "${YELLOW}Into:${NC} $CONFIG_DIR"
            read -p "Import now? (y/N) " -n 1 -r
            echo ""
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                import_local_config "merge"
                echo "yes" > "$IMPORT_MARKER" 2>/dev/null || true
            else
                echo "no" > "$IMPORT_MARKER" 2>/dev/null || true
            fi
        fi
    fi
fi

# Copy auth.json if it exists and is newer (or doesn't exist in config)
if [ "$CONFIG_DIR" != "$LOCAL_CONFIG_DIR" ] && [ -f "$AUTH_FILE" ]; then
    if [ ! -f "$CONFIG_DIR/auth.json" ] || [ "$AUTH_FILE" -nt "$CONFIG_DIR/auth.json" ]; then
        cp "$AUTH_FILE" "$CONFIG_DIR/auth.json"
    fi
fi

# Sync project-local skills (if any)
sync_project_skills

# Ensure browser tools are present when headless browser requested
ensure_browser_tools

# Check if image exists
image_exists() {
    container image inspect "$IMAGE_NAME" >/dev/null 2>&1
}

# Check if this is first run (no image exists)
FIRST_RUN=false
if ! image_exists; then
    FIRST_RUN=true
    first_run_welcome
fi

# Build image if needed
if [ "$FIRST_RUN" = true ]; then
    echo -e "${CYAN}Building container image...${NC} ${DIM}(this takes a few minutes)${NC}"
    echo ""
    build_image 2>&1 | while read line; do
        # Show only key progress lines
        if [[ "$line" =~ ^"#"[0-9]|"DONE"|"ERROR" ]]; then
            echo -e "${DIM}$line${NC}"
        fi
    done
    echo ""
    echo -e "${GREEN}✓${NC} Image built successfully!"
    echo ""
fi

# Create project directory if specified
if [ -n "$PROJECT_NAME" ]; then
    mkdir -p "$WORKSPACE/$PROJECT_NAME"
fi

# Show startup info
if [ "$CONTAINER_CMD" = "pi" ]; then
    header
    if [ -n "$PROJECT_NAME" ]; then
        echo -e "${DIM}Project:${NC}   ${BOLD}$PROJECT_NAME${NC}"
        echo -e "${DIM}Path:${NC}      $WORKSPACE/$PROJECT_NAME"
        if [ "$RESTRICT_WORKSPACE" = "1" ]; then
            echo -e "${DIM}Mount:${NC}     $WORKSPACE_MOUNT → /workspace"
        fi
        echo -e "${DIM}Config:${NC}    $CONFIG_DIR"
    else
        status_info
    fi
    echo ""
fi

# Ensure image exists before running
if ! image_exists; then
    echo -e "${CYAN}Image not found. Building...${NC}"
    build_image
fi

# Ensure container uses compatible entrypoint
ensure_container_compat

# Run in container
CONTAINER_WAS_RUNNING=false
if container_running; then
    CONTAINER_WAS_RUNNING=true
fi

TTY_FLAG=""
if [ -t 0 ] && [ -t 1 ]; then
    TTY_FLAG="-t"
fi

EXEC_ENV=()
if [ "$CONTAINER_CMD" = "pi" ]; then
    EXEC_ENV=(--env HOME="$CONTAINER_HOME")
fi

if container_exists; then
    if ! container_running; then
        echo -e "${DIM}Starting container...${NC}"
        container start "$CONTAINER_NAME" >/dev/null
        wait_for_container_running
    fi
else
    echo -e "${DIM}Creating container...${NC}"
    container run -d \
        --name "$CONTAINER_NAME" \
        --volume "$WORKSPACE_MOUNT:/workspace" \
        --volume "$CONFIG_DIR:$CONTAINER_CONFIG_PATH" \
        -w "$WORKDIR" \
        ${USER_FLAG[@]} \
        --cpus 4 \
        --memory 4G \
        ${SSH_FLAG[@]} \
        ${BROWSER_ENV[@]} \
        "$IMAGE_NAME" \
        /bin/bash -lc "sleep infinity" >/dev/null
    wait_for_container_running
fi

start_headless_browser_in_container
container exec -i $TTY_FLAG ${USER_FLAG[@]} ${EXEC_ENV[@]} ${BROWSER_ENV[@]} -w "$WORKDIR" "$CONTAINER_NAME" $CONTAINER_CMD "$@"
EXIT_CODE=$?

if [ "$CONTAINER_WAS_RUNNING" = false ]; then
    container stop "$CONTAINER_NAME" >/dev/null 2>&1 || true
fi

exit $EXIT_CODE
